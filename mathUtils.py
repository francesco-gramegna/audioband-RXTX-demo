import numpy as np

#generated by chatgpt
def rrc_pulse(fs, rs, alpha=0.25, span_symbols=12):
    """
    Generate a Root Raised Cosine (RRC) pulse.
    
    fs: sampling frequency
    rs: symbol rate
    alpha: roll-off factor (0..1)
    span_symbols: total length of pulse in symbols
    
    Returns:
        rrc : pulse shaping filter (numpy array)
        t   : time base for the filter
    """
    Ts = 1 / rs                      # symbol period
    t_step = 1 / fs                  # sampling period
    
    # total pulse length in seconds
    t_max = span_symbols * Ts / 2
    
    # time vector (centered at zero)
    t = np.arange(-t_max, t_max + t_step, t_step)
    
    # allocate pulse
    rrc = np.zeros_like(t)

    for i, ti in enumerate(t):
        if abs(ti) < 1e-12:
            # t = 0 special case
            rrc[i] = 1.0 + alpha * (4/np.pi - 1)
        
        elif abs(abs(ti) - Ts/(4*alpha)) < 1e-12:
            # t = ±Ts/(4α) special case
            rrc[i] = (alpha/np.sqrt(2)) * (
                (1 + 2/np.pi) * np.sin(np.pi/(4*alpha)) +
                (1 - 2/np.pi) * np.cos(np.pi/(4*alpha))
            )
        
        else:
            # general case
            numerator = (
                np.sin(np.pi * ti * (1 - alpha) / Ts) +
                4 * alpha * (ti / Ts) *
                np.cos(np.pi * ti * (1 + alpha) / Ts)
            )
            denominator = (
                np.pi * ti * (1 - (4 * alpha * ti / Ts)**2) / Ts
            )
            rrc[i] = numerator / denominator

    # normalize so pulse energy = 1
    rrc /= np.sqrt(np.sum(rrc**2))

    return rrc




#generated by ai
class SimpleAGC:
    def __init__(self, target_power=1.0, alpha=0.01, min_gain=1e-6, max_gain=100):
        """
        - target_power : desired average |x|^2
        - alpha : adaptation step size (0.001 - 0.1)
        - min_gain / max_gain : clamps to prevent runaway
        """
        self.target_power = target_power
        self.alpha = alpha
        self.gain = 1.0
        self.min_gain = min_gain
        self.max_gain = max_gain

    def process(self, x):
        if len(x) == 0:
            return x

        # Estimate window power
        power = np.mean(np.abs(x)**2)

        # Avoid log(0)
        if power < 1e-12:
            power = 1e-12

        # Error term in log domain
        error_db = np.log(self.target_power) - np.log(power)

        # Slowly adjust gain in linear domain
        self.gain *= np.exp(self.alpha * error_db)

        # Clamp gain
        self.gain = np.clip(self.gain, self.min_gain, self.max_gain)

        return x * self.gain

